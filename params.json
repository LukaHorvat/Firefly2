{"name":"Firefly 2","tagline":"A new, clean, component-based version of FireflyGL, the C#/OpenGL 2D rendering and game engine.","body":"### Example usage\r\nHere's a quick example you can paste in your Program.Main that will display a colored square on your screen.\r\n\r\n```csharp\r\nvar stage = new Stage(800, 500, \"Hello World\");\r\n\r\nstage.TreeNode.AddChild(new Entity\r\n{\r\n\tnew GeometryComponent\r\n\t{\r\n\t\tnew Vector2d(0, 0),\r\n\t\tnew Vector2d(100, 0),\r\n\t\tnew Vector2d(100, 100),\r\n\t\tnew Vector2d(0, 100)\r\n\t},\r\n\tnew ShapeColorComponent\r\n\t{\r\n\t\tnew Vector4(1, 0, 0, 1),\r\n\t\tnew Vector4(0, 1, 0, 1),\r\n\t\tnew Vector4(0, 0, 1, 1),\r\n\t\tnew Vector4(1, 1, 0, 1)\r\n\t},\r\n\tnew RenderBufferComponent(stage.Renderer),\r\n\tnew TreeNodeComponent()\r\n});\r\n\r\nstage.Run();\r\n```\r\nFirst we make a new Stage instance. The stage is an entity to which you attach other entities that you want on the screen.\r\nTreeNode is a shorthand that points to the stage's TreeNodeComponent. Shorthands will be discussed in the next section.\r\nThe TreeNodeComponent is they way you connect entities together in a hierarchical order.\r\nWe supply the AddChild method with a new entity which we construct on the spot adding some components to it.\r\nThe GeometryComponent provides the mesh coordinate data. It doesn't contain color information or texture coordinates so it can be used for purposes other than rendering.\r\nThe ShapeColorComponent adds the color data to those points.\r\nNext, we add the RenderBufferComponent and the TreeNodeComponent. The render buffer will process the geometry and color data and update the internal buffer that is later rendered.\r\nWe need the tree node so we have an \"attachment point\" for the stage's tree node.\r\n\r\nAfter the setup is done, we call stage.Run. This blocks further code execution until we close the opened window.\r\n\r\n### Shorthands\r\nShorthands are a handy way to quickly access components in an entity. When making a new entity subclass, you can use shorthands like this\r\n```csharp\r\n[Shorthand]\r\npublic TransformComponent Transform { get; set; }\r\n```\r\nThe property will magically always have the value of the current TransformComponent attached to the entity that has it.\r\nThey they have some restrictions. You can only use them on entities and you can only use them with automatic properties. They will work with normal properties as long as the getter\r\nreturns the last set value.\r\nThere are no restrictions to the accessibility modifier.\r\n\r\n### Parent-child system\r\n\r\nNow lets look at a slightly more complicated example. We'll take our entity and put it in a MakeRectangle function. Also, we'll modify it slightly.\r\n```csharp\r\nstatic Entity MakeRectangle(Renderer renderer)\r\n{\r\n\treturn new Entity\r\n\t{\r\n\t\tnew GeometryComponent\r\n\t\t{\r\n\t\t\tnew Vector2d(0, 0),\r\n\t\t\tnew Vector2d(200, 0),\r\n\t\t\tnew Vector2d(200, 100),\r\n\t\t\tnew Vector2d(0, 100)\r\n\t\t},\r\n\t\tnew ShapeColorComponent\r\n\t\t{\r\n\t\t\tnew Vector4(1, 0, 0, 1),\r\n\t\t\tnew Vector4(0, 1, 0, 1),\r\n\t\t\tnew Vector4(0, 0, 1, 1),\r\n\t\t\tnew Vector4(1, 1, 0, 1)\r\n\t\t},\r\n\t\tnew RenderBufferComponent(renderer),\r\n\t\tnew TreeNodeComponent(),\r\n\t\tnew TransformComponent()\r\n\t};\r\n```\r\n\r\nWe elongated the rectangle, and we added a new component. The TransformComponent, like it's name says, handles transformations. That's stuff like X, Y, Rotation and Scale.\r\nSo let's make a few rectangles and link them together.\r\n```csharp\r\nvar stage = new Stage(800, 500, \"Hello World\");\r\n\r\nvar a = MakeRectangle(stage.Renderer);\r\nvar b = MakeRectangle(stage.Renderer);\r\nvar c = MakeRectangle(stage.Renderer);\r\na.GetComponent<TreeNodeComponent>().AddChild(b);\r\nb.GetComponent<TreeNodeComponent>().AddChild(c);\r\nb.GetComponent<TransformComponent>().X = 200;\r\nc.GetComponent<TransformComponent>().X = 200;\r\n\r\na.GetComponent<TransformComponent>().ScaleX = 0.5;\r\na.GetComponent<TransformComponent>().ScaleY = 0.5;\r\n\r\nstage.TreeNode.AddChild(a);\r\n\r\nstage.Run();\r\n```\r\n\r\nSo let's see here. We make 3 rectangles, link them a -> b -> c and then modify some of their properties. We put b and c at X = 200. We also shrink a by half.\r\nThen we add a to stage.\r\nWhat we see when we run the program are all three rectangles because you don't need to add each of them separately to the stage. You need to add the root of the tree you want displayed.\r\nSecondly, the first rectangle isn't the only one scaled. They are all the same size. Why? Because changing the transformation of the parent entity changes the coordinate system of the\r\nchild entity. This also means that b and c are not in the same spot because b is shifter 200 to the right RELATIVE TO a and c is shifter 200 to the right RELATIVE TO b.\r\nIn fact, they are only shifted by 100 each since the whole coordinate system is scaled to one half.\r\n\r\nIf we were to rotate a, the whole stick of rectangles would rotate.\r\n\r\nOne extra thing to note here is that we need to use GetComponent<TreeNodeComponent> instead of just TreeNode since we didn't (and can't) define a shorthand.\r\nThis is because we made a new entity on the spot instead of making a new class that inherits from entity. Since writing GetComponent<...> gets real boring\r\nreal fast, shorthands were introduced.\r\n\r\n### Mouse interaction\r\n\r\nNext, let's take a look at mouse interaction. The idea is simple. We want to know if an object if being hovered over with the mouse. If it is, make it grow slightly.\r\nThis is how it should look.\r\n```csharp\r\nstatic Entity MakeRectangle(Renderer renderer)\r\n{\r\n\treturn new Entity\r\n\t{\r\n\t\tnew GeometryComponent\r\n\t\t{\r\n\t\t\tnew Vector2d(0, 0),\r\n\t\t\tnew Vector2d(200, 0),\r\n\t\t\tnew Vector2d(200, 100),\r\n\t\t\tnew Vector2d(0, 100)\r\n\t\t},\r\n\t\tnew ShapeColorComponent\r\n\t\t{\r\n\t\t\tnew Vector4(1, 0, 0, 1),\r\n\t\t\tnew Vector4(0, 1, 0, 1),\r\n\t\t\tnew Vector4(0, 0, 1, 1),\r\n\t\t\tnew Vector4(1, 1, 0, 1)\r\n\t\t},\r\n\t\tnew RenderBufferComponent(renderer),\r\n\t\tnew TreeNodeComponent(),\r\n\t\tnew TransformComponent(renderer),\r\n\t\tnew MouseInteractionComponent()\r\n\t};\r\n}\r\n```\r\n\r\n```csharp\r\nvar stage = new Stage(800, 500, \"Hello World\");\r\n\r\nvar a = MakeRectangle(stage.Renderer);\r\nvar b = MakeRectangle(stage.Renderer);\r\nvar c = MakeRectangle(stage.Renderer);\r\nb.GetComponent<TransformComponent>().X = 100;\r\nc.GetComponent<TransformComponent>().X = 200;\r\n\r\nge.Update.Update += delegate\r\n{\r\n\tnew List<Entity>() { a, b, c }.ForEach(ent =>\r\n\t{\r\n\t\tvar intersects = ent.GetComponent<MouseInteractionComponent>().IntersectsMouse;\r\n\t\tif (intersects)\r\n\t\t{\r\n\t\t\tent.GetComponent<TransformComponent>().ScaleX = 0.6;\r\n\t\t\tent.GetComponent<TransformComponent>().ScaleY = 0.6;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tent.GetComponent<TransformComponent>().ScaleX = 0.5;\r\n\t\t\tent.GetComponent<TransformComponent>().ScaleY = 0.5;\r\n\t\t}\r\n\t});\r\n};\r\n\r\nstage.TreeNode.AddChild(a);\r\nstage.TreeNode.AddChild(b);\r\nstage.TreeNode.AddChild(c);\r\n\r\nstage.Run();\r\n```\r\n\r\nOk. So there are a lot of interesting things going on here.\r\nFirstly, let's look at our MakeRectangle function. It adds a MouseInteractionComponent to our entities.\r\nThe setup is similar to the last section except this time the entities aren't linked and they are each added separately to the stage.\r\nThen, we hook onto the stage's update event. Stage has an Update shorthand that points to it's UpdateComponent. That component has an Update event\r\nand an AfterUpdate event that you can add your listeners too.\r\nOn each update, for each rectangle we check if it intersects the coordinates of the mouse.\r\n\r\nThis is not a finished feature. The final version will not require so much under-the-hood work.\r\n\r\nIf the mouse intersects the object, we scale it. If it doesn't, we keep the scale at 0.5.\r\n\r\n\r\n### Support or Contact\r\nHaving trouble with Firefly2? You can email me at lukahorvat9@gmail.com","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}